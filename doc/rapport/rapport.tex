\documentclass[french, 12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{babel}
\usepackage{hyperref}
\usepackage{graphicx}

\title{Rapport Projet Informatique du Métro}
\author{
  Bouarah Romain \and
  Langdorph Matthieu \and
  Ketels Lucas \and
  Souffan Nathan
}


\begin{document}
\maketitle

Dans le cadre du Projet Informatique du 4ème semestre, voici le projet Métro. Ce programme permet de donner le trajet le plus court lors d'un déplacement sur un réseau de métro, représenté par un graphe. Ce programme a été codé en Java.  
\newpage
\tableofcontents

 
\newpage

\part{Guide d'utilisation du programme}
Voici des indications pour utiliser notre programme "metro". Nous l'avons conçu avec Maven, JUnit et Java.

\section{Installation}
Avant d'installer le programme, il faut vérifier bien avoir Java JDK, Maven et JUnit d'installer sur son ordinateur. Sinon les installer. Il faut également vérifier que les versions sont suffisament à jour, version au moins 8.0 pour Java, au moins 3.6 pour Maven, et au moins 4.11 pour JUnit.
Vous pouvez alors cloner le projet depuis master dans les fichiers de votre ordinateur.
Vous êtes alors prêt pour utiliser "metro".

\section{Utilisation}
Une fois la partie installation effectuée, vous pouvez compiler et exécuter "metro".
Se placer dans le répertoire adapté et se positionner sur master(par défaut).
Pour compiler le projet dans son intégralité, il faut utiliser la commande "make".
Il y a la possibilité de compiler juste datamodel ou le webserver, en faisant suivre leur nom après "make".
On peut compiler les tests avec "make test".
"make clean" supprime tous les fichiers produits pendant la compilation.

Pour exécuter le programme : on peut soit avoir une version minimale sur le terminal avec la commande "make run\_terminal". Sinon on peut avoir la version site Web en utilisant la commande "make run".

Nous allons donc voir comment utiliser le webserver "metro" dans la section suivante.

Nous avons également l'option d'afficher le graphe du réseau d'une ville en utilisant la commande "make export\_to\_dot ARGS="NomDeLaVille" ". Notons que les réseaux de métro des villes de Lille, Lyon, Marseille, Rennes, Toulouse, Paris, et des aéroports de Charles de gaulle et Orly.

\section{Exemple d'exécution}
Nous compilons donc avec la commande "make".
Nous lançons ensuite l'exécution avec "make run".

\includegraphics[height=5cm]{images/execute.png}

Il faut alors copier le lien(2ème ligne partant du bas) dans un navigateur web pour accéder au webserver de "metro". Cette page ci-dessous s'affiche et on sélectionne alors la ville de notre choix parmi celles possibles. On prend Paris dans cet exemple.

\includegraphics[height=3cm]{images/pageDAccueil.png}

Nous pouvons alors rechercher un itinéraire. Ici de Wagram à Ourcq. Trois options s'offrent à nous : utiliser Dijkstra(Shortest) pour trouver le plus court chemin, l'algorithme de Floyd ou l'algorithme de Bouarah pour trouver le plus court chemin avec un plafond de nombre de correspondances.

\includegraphics[height=3cm]{images/research.png}

Nous faisons ici une recherche avec Shortest. S'affichent alors plusieurs itinéraires dans l'ordre croissant en fonction des temps de trajets.

\includegraphics[height=8cm]{images/itineraryWithoutPbs.png}

Retournons à la page d'avant, on remarque la possibilité d'ajouter des perturbations de trafics. On peut arrêter ou ralentir une ligne ou une partie d'une ligne, fermer une station, fermer une ligne dans une station. Notre itinéraire précédent nous faisais passer par la ligne 2. Fermons donc la ligne 2 puis effectuons la même recherche de trajet entre Wagram et Ourcq.

\includegraphics[height=4cm]{images/traficsPerturb.png}
\includegraphics[height=4cm]{images/researchWithPbs.png}

On peut à présent voir le trajet le plus court sachant que la ligne 2 est fermée.

\includegraphics[height=8cm]{images/itineraryWithPbs.png}

Retournons maintenant à la page d'avant, allons en bas de page, et on peut voir qu'une section "Statistics" propose un lien vers une page affichant les statistiques du réseau de métro de la ville sélectionnée au préalable.

\includegraphics[width=12cm]{images/acceedStats.png}

Voici l'affichage de cette page :

\includegraphics[height=6cm]{images/stats.png} 

Voici la fin de cet exemple d'utilisation de "metro" via son webserver.


 
\newpage

\part{Projet Métro}
Dans cette partie est expliqué les différents algorithmes, la structure des classes du  projet, et sa présentation générale.
\section{Présentation générale}
Voici la présentation du projet avec les choix de modélisation que nous avons fait, les problèmes rencontrés durant celui-ci et la manière dont on l'a organisé.
\subsection{Modélisation}
%partie de qui veut
%Expliquer les choix de modélisation qu'on a pris. Pourquoi ceux ci et pas d'autres? 
%Le choix de faire des meta station, le choix de mettre des files de propriétés, pq avoir fait deux algos avec correspondance, choix d'implémentation du parser.

\subsection{Organisation}
Comme vu précédemment, au début du semestre, nous avons dû faire des choix de modélisation et donc réfléchir. Nous avons d'abord créé le graphe(W\-Graph) car ce graphe représente dans notre réseau de métro. 
Parallèlement nous avons créé un parser pour construire un graphe à partir d'un fichier contenant les stations par ligne, d'un réseau de métro. 
Nous avons également en un premier temps écrit l'algo de Dijkstra(puis avec la file de priorité).
Nous avons alors pu commencer à écrire les algorithmes avec une limite de correspondances, l'algorithme de Floyd avec les matrices, et l'"algorithme de Bouarah", dont il est parlé dans la section suivante.
Nous avons également ajouter un webserver, car cela commençait à faire lourd de toujours tester sur le terminal.
Nous avons alors rajouté les algorithmes pour les statistiques des réseaux de métro. 
Rajoutons que le programme est en anglais car il peut être utilisé pour tout les réseaux de métro. Ici seul ceux en France sont disponible, mais il n'y a pas de problèmes, car il y a juste à stocker le réseau voulu, par un fichier texte adapté, en objet JSON dans les fichiers JSON correspondants.
Nous avons ensuite rajouté la possibilité d'ajouter des perturbations sur nos réseaux métro.
Arrivé à mi-avril, nous avons bien avancé, et il nous reste à améliorer alors notre programme, en rendant un code plus propre et amélioré, améliorer le webserver, régler des bugs, etc...

Notons qu'à chaque tâche attribuée, la personne s'occupant de la tâche doit s'occuper des tests qui vont avec. En général les tâches doivent être faites pour la semaine suivante.
Notre système nous a été efficace, et permis de travailler dans de bonnes conditions.
A chaque fin de tâche, la personne s'en occupant devait attribuer une "merge request" à quelqu'un d'autre pour vérifier son travail et avoir un autre point de vue de la question et voir les éventuels problèmes. 
\subsection{Problèmes rencontrés}
Certains problèmes ont été rencontrer durant ce projet. 
Au début du projet nous avions le problème de ne pas savoir par où commencer, ou plutôt nous avions peur de partir trop vite en s'emballant ou d'aller trop lentement et perdre du temps. Nous avons donc eu au début du projet, des semaines où il y avait peu de tâches à effectuer et où nous avions du mal à en trouver. Trouver des tâches précises n'était pas non plus facile. 
D'où l'importance de s'imprégner vraiment du projet ou d'une partie du projet pour pouvoir décomposer cela en de multiples tâches. Il y a donc eu des tâches trop vagues, et cela a pu être un léger problème par moment. Dans l'implémentation des algorithmes, il y avait ce besoin nécessaire de s'imprégner de l'algorithme pour voir clairement ce que nous voulons. Cela demande un vrai travail de réflexion et de la concentration. Il y a eu une grosse demande de concentration et réflexion pour réussir à faire un bon parser, en cherchant les problèmes qu'il pourrait y avoir dans les modifications que l'on voudrait apporter.
Un autre problème qui peut intervenir et de replonger dans du code que l'on a écrit quelques mois auparavant ou de se plonger dans du code que nous n'avions pas écrit. Le challenge était donc de se maintenir à jour sur les avancées du projet.
Pour les algorithmes, ce qui posait problème, était la réflexion autour de la modélisation pour faire marcher les algorithmes, qui en eux-mêmes n'ont pas posé de problèmes d'implémentations.



\newpage
\section{Les classes plus en détail}
Notre programme a de nombreuses classes de code. On peut y trouver un parser, plusieurs algorithmes, une pour les perturbations, et d'autres pour le webserver. Elles vont être expliquées plus en détail pour le parser et les algorithmes ci-dessous. Nous allons également présenter ci-dessous la structure du projet et de ses classes. 
\subsection{Le parser}
%Partie Nathan

\subsection{Les différents algorithmes}
Voici une présentation des trois algorithmes de plus court chemin que nous avons utilisé dans ce projet: l'algorithme de Dijkstra, celui de Floyd et celui de Bouarah. 
\subsubsection{Dijkstra}
L'algorithme de Dijkstra ne fût pas forcément facile à comprendre. Mais une fois imprégnés de celui-ci, nous avons pu faire un algorithme clair répondant au problème du plus court chemin. Au départ nous n'utilisions pas de file de priorité.
Une fois que l'algorithme marchait, nous avons rajouté les files de priorité en guise d'amélioration.
A partir d'un graphe et d'une station on peut alors lancer l'algorithme avec aussi une hashmap correspondant aux distances des stations par rapport à la station initiale avec le plus court chemin entre elles, et une autre hashmap où chaque clé est une station avec une valeur associée qui est sa station précédente par rapport à la station initiale en prenant le chemin le plus court.
Avant l'analyse du graphe, il y a initialisation de la hashmap en associant des distances à l'infini en valeur pour chaque station(clé) du graphe, et pareil pour la file de priorité. 

\subsubsection{Algorithme de Floyd}
%Partie Lucas

\subsubsection{Algorithme de Bouarah}
%Partie romain

\subsection{Structure des classes}
%Diagramme des classes à rajouter


\end{document}
